import { execaSync } from 'execa';
import fs from 'fs-extra';
import os from 'os';
import path from 'path';
import { describe, expect, it } from 'vitest';

/**
 * Smoke tests for the CLI tool, validating core output formats and behaviors.
 */
describe('CLI smoke test', () => {
  it('discovers duplicate interfaces and outputs valid JSON', () => {
    // Create a temp directory containing three TypeScript files
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'dry-cli-'));
    const files = {
      'a.ts': `export interface Foo { x: number; }`,
      'b.ts': `export interface Foo { x:number; }`,
      'c.ts': `export interface Bar { y: string }`,
    };
    Object.entries(files).forEach(([name, content]) => {
      fs.writeFileSync(path.join(tmpDir, name), content);
    });

    // Run the CLI under Bun in JSON mode with perfect similarity threshold
    const cliPath = path.resolve(__dirname, 'cli.tsx');
    const result = execaSync('bun', [cliPath, tmpDir, '--json', '--threshold', '1'], {
      encoding: 'utf8',
    });

    // Expect successful exit and parseable JSON output
    expect(result.exitCode).toBe(0);
    const groups = JSON.parse(result.stdout);
    expect(Array.isArray(groups)).toBe(true);
    expect(groups).toHaveLength(1);

    // Verify the duplicate group contains the two Foo interfaces
    const [group] = groups;
    expect(group.similarity).toBe(1);
    const duplicateFiles = group.decls.map((d: any) => path.basename(d.location.file)).sort();
    expect(duplicateFiles).toEqual(['a.ts', 'b.ts']);
  });
});

/**
 * Tests for SARIF output format (--sarif).
 */
describe('CLI SARIF output (--sarif)', () => {
  it('emits valid SARIF v2.1.0 with a runs array', () => {
    // Set up two identical interface files in a temp directory
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'dry-cli-sarif-'));
    const schema = `export interface Foo { x: number }`;
    ['a.ts', 'b.ts'].forEach(name => {
      fs.writeFileSync(path.join(tmpDir, name), schema);
    });

    // Invoke CLI with --sarif flag
    const cliPath = path.resolve(__dirname, 'cli.tsx');
    const result = execaSync('bun', [cliPath, tmpDir, '--sarif'], { encoding: 'utf8' });

    // Expect success and valid SARIF JSON
    expect(result.exitCode).toBe(0);
    let sarif: any;
    expect(() => {
      sarif = JSON.parse(result.stdout);
    }).not.toThrow();
    expect(sarif).toHaveProperty('version', '2.1.0');
    expect(Array.isArray(sarif.runs)).toBe(true);
  });
});

/**
 * Tests for fix file generation (--fix) and output file writing.
 */
describe('CLI fix mode (--fix)', () => {
  it('writes a fix file containing aliases for exact matches', () => {
    // Create two identical interface files
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'dry-cli-fix-'));
    const schema = `export interface Foo { x: number }`;
    ['a.ts', 'b.ts'].forEach(name => {
      fs.writeFileSync(path.join(tmpDir, name), schema);
    });

    // Run CLI with --fix and specify an output file path
    const cliPath = path.resolve(__dirname, 'cli.tsx');
    const outputFile = path.join(tmpDir, 'dup.ts');
    const result = execaSync('bun', [cliPath, tmpDir, '--fix', '--out', outputFile], {
      encoding: 'utf8',
    });

    // Expect successful execution and existence of the fix file
    expect(result.exitCode).toBe(0);
    expect(fs.existsSync(outputFile)).toBe(true);

    // Read and verify contents of the generated fix file
    const content = fs.readFileSync(outputFile, 'utf8');
    expect(content).toMatch(/Auto-generated by dry-lint/);
    expect(content).toMatch(/export type Foo = \{\s*\/\* replace with real shape \*\/\};/);
    expect(content).toMatch(/export type Foo = Foo;/);
  });
});

/**
 * Tests for ignoring files via glob patterns (--ignore).
 */
describe('CLI ignore patterns (--ignore)', () => {
  it('does not report duplicates for ignored files', () => {
    // Prepare two identical interface files
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'dry-cli-ignore-'));
    const schema = `export interface Foo { x: number }`;
    ['a.ts', 'b.ts'].forEach(name => {
      fs.writeFileSync(path.join(tmpDir, name), schema);
    });

    // Invoke CLI in JSON mode while ignoring b.ts
    const cliPath = path.resolve(__dirname, 'cli.tsx');
    const result = execaSync('bun', [cliPath, tmpDir, '--json', '--ignore', 'b.ts'], {
      encoding: 'utf8',
    });

    // Expect no duplicate groups reported
    expect(result.exitCode).toBe(0);
    const groups = JSON.parse(result.stdout);
    expect(Array.isArray(groups)).toBe(true);
    expect(groups).toHaveLength(0);
  });
});

/**
 * Tests for fuzzy matching at threshold < 1.
 */
describe('CLI fuzzy matching (--threshold)', () => {
  it('finds near-duplicates when threshold is below 1', () => {
    // Create two interfaces with slight differences
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'dry-cli-fuzzy-'));
    fs.writeFileSync(path.join(tmpDir, 'a.ts'), `export interface Foo { x: number; y: string }`);
    fs.writeFileSync(path.join(tmpDir, 'b.ts'), `export interface Foo { x: number }`);

    // Run CLI with threshold set to 0.5
    const cliPath = path.resolve(__dirname, 'cli.tsx');
    const result = execaSync('bun', [cliPath, tmpDir, '--json', '--threshold', '0.5'], {
      encoding: 'utf8',
    });

    // Expect one duplicate group with partial similarity
    expect(result.exitCode).toBe(0);
    const groups = JSON.parse(result.stdout);
    expect(groups).toHaveLength(1);
    const [group] = groups;
    expect(typeof group.similarity).toBe('number');
    expect(group.similarity).toBeGreaterThan(0);
    expect(group.similarity).toBeLessThan(1);
    const files = group.decls.map((d: any) => path.basename(d.location.file)).sort();
    expect(files).toEqual(['a.ts', 'b.ts']);
  });
});

/**
 * Tests for help output and error handling on invalid paths.
 */
describe('CLI help & error handling', () => {
  const cliPath = path.resolve(__dirname, 'cli.tsx');

  it('displays usage information with --help and exits successfully', () => {
    const result = execaSync('bun', [cliPath, '--help'], { encoding: 'utf8' });
    expect(result.exitCode).toBe(0);
    expect(result.stdout).toMatch(/Usage: dry/);
    expect(result.stdout).toMatch(/--json/);
    expect(result.stdout).toMatch(/--sarif/);
    expect(result.stdout).toMatch(/--fix/);
  });

  it('exits with error when provided a nonexistent path', () => {
    const fakeDir = path.join(os.tmpdir(), 'does-not-exist-xyz');
    const result = execaSync('bun', [cliPath, fakeDir, '--json'], {
      encoding: 'utf8',
      reject: false,
    });

    // Expect non-zero exit code and error message about path not found
    expect(result.exitCode).not.toBe(0);
    const output = result.stderr || result.stdout;
    expect(output).toMatch(/ENOENT|not found/i);
  });
});
